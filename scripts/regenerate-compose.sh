#!/usr/bin/env bash
# =============================================================================
# Regenerate docker-compose.yml with source mounts from database
# This script reads source_mounts from robomonkey_control and updates
# the docker-compose.yml to include them as bind mounts.
# =============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
cd "$PROJECT_DIR"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
RED='\033[0;31m'
NC='\033[0m'

echo -e "${BLUE}Regenerating docker-compose.yml with source mounts...${NC}"

# Check if postgres is running
if ! docker ps --format '{{.Names}}' 2>/dev/null | grep -q "robomonkey-postgres"; then
    echo -e "${RED}Error: Postgres container is not running${NC}"
    echo "Start it with: ./scripts/db-start.sh"
    exit 1
fi

# Get source mounts from database
echo "Fetching source mounts from database..."
MOUNTS_JSON=$(docker exec robomonkey-postgres psql -U postgres -d robomonkey -tAc "
    SELECT json_agg(json_build_object(
        'mount_name', mount_name,
        'host_path', host_path,
        'container_path', container_path,
        'read_only', read_only
    ))
    FROM robomonkey_control.source_mounts
    WHERE enabled = true
" 2>/dev/null || echo "null")

# Handle empty result
if [ "$MOUNTS_JSON" = "null" ] || [ -z "$MOUNTS_JSON" ] || [ "$MOUNTS_JSON" = "" ]; then
    MOUNTS_JSON="[]"
    echo "No enabled source mounts found."
else
    # Trim whitespace
    MOUNTS_JSON=$(echo "$MOUNTS_JSON" | tr -d '[:space:]')
    MOUNT_COUNT=$(echo "$MOUNTS_JSON" | python3 -c "import sys,json; print(len(json.load(sys.stdin)))" 2>/dev/null || echo "0")
    echo "Found $MOUNT_COUNT enabled source mount(s)."
fi

# Load existing settings from .env if it exists
if [ -f "$PROJECT_DIR/.env" ]; then
    source "$PROJECT_DIR/.env" 2>/dev/null || true
fi

# Set defaults
DB_HOST="${DB_HOST:-localhost}"
DB_PORT="${DB_PORT:-5436}"
DB_USER="${DB_USER:-postgres}"
DB_PASSWORD="${DB_PASSWORD:-postgres}"
DB_NAME="${DB_NAME:-robomonkey}"

# Generate the docker-compose.yml
echo "Generating docker-compose.yml..."

# Build volume mounts string
VOLUME_MOUNTS=""
if [ "$MOUNTS_JSON" != "[]" ]; then
    VOLUME_MOUNTS=$(echo "$MOUNTS_JSON" | python3 -c "
import sys, json
mounts = json.load(sys.stdin)
for m in mounts:
    ro = ':ro' if m['read_only'] else ''
    print(f\"      - {m['host_path']}:{m['container_path']}{ro}\")
" 2>/dev/null || echo "")
fi

cat > "$PROJECT_DIR/docker-compose.yml" << EOF
# RoboMonkey - Docker Compose (Native Mode)
# Only Postgres runs in Docker, daemon runs natively on host
# Generated by regenerate-compose.sh on $(date)

services:
  # PostgreSQL with pgvector
  postgres:
    image: pgvector/pgvector:pg16
    container_name: robomonkey-postgres
    environment:
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_DB: ${DB_NAME}
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./scripts/init_db.sql:/docker-entrypoint-initdb.d/01_init_schema.sql:ro
${VOLUME_MOUNTS}
    ports:
      - "${DB_PORT}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d robomonkey"]
      interval: 5s
      timeout: 5s
      retries: 10
    restart: unless-stopped

volumes:
  pgdata:
    name: robomonkey_pgdata

networks:
  default:
    name: robomonkey_network
EOF

echo -e "${GREEN}docker-compose.yml regenerated!${NC}"

# Show the source mounts that were added
if [ -n "$VOLUME_MOUNTS" ]; then
    echo ""
    echo "Source mounts added:"
    echo "$VOLUME_MOUNTS" | sed 's/^      - /  - /'
fi

# Ask about restart
echo ""
read -p "Restart containers to apply changes? [Y/n]: " RESTART
RESTART=${RESTART:-y}

if [[ "$RESTART" =~ ^[Yy]$ ]]; then
    echo ""
    echo -e "${YELLOW}Restarting containers...${NC}"

    # Detect docker compose command
    if docker compose version &>/dev/null; then
        DC_CMD="docker compose"
    elif command -v docker-compose &>/dev/null; then
        DC_CMD="docker-compose"
    else
        echo -e "${RED}Error: Neither 'docker compose' nor 'docker-compose' found${NC}"
        exit 1
    fi

    # Stop and start postgres
    $DC_CMD down
    $DC_CMD up -d postgres

    # Wait for postgres to be ready
    echo "Waiting for Postgres to be ready..."
    for i in {1..30}; do
        if docker exec robomonkey-postgres pg_isready -U postgres &>/dev/null; then
            echo -e "${GREEN}Postgres is ready!${NC}"

            # Re-initialize control schema if needed
            if ! docker exec robomonkey-postgres psql -U postgres -d robomonkey -tAc \
                "SELECT 1 FROM information_schema.schemata WHERE schema_name = 'robomonkey_control'" 2>/dev/null | grep -q 1; then
                echo "Initializing control schema..."
                docker exec -i robomonkey-postgres psql -U postgres -d robomonkey < "$SCRIPT_DIR/init_control.sql"
            fi

            break
        fi
        sleep 1
    done

    echo ""
    echo -e "${GREEN}Containers restarted with new mounts!${NC}"

    # Show status
    echo ""
    echo "Current mounts in container:"
    docker inspect robomonkey-postgres --format '{{range .Mounts}}{{if eq .Type "bind"}}  - {{.Source}} -> {{.Destination}}{{if not .RW}} (ro){{end}}
{{end}}{{end}}' 2>/dev/null || echo "  (unable to inspect)"

else
    echo ""
    echo -e "${YELLOW}Skipped restart. Run manually:${NC}"
    echo "  docker compose down && docker compose up -d postgres"
fi

echo ""
echo -e "${GREEN}Done!${NC}"
